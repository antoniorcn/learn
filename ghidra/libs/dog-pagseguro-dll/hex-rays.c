/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *sub_180001000();
int sub_180001010(FILE *Stream, char *Format, ...);
int sub_180001060(char *Format, ...);
const char *sub_1800010C0();
char *sub_180001170();
int sub_180001230(int a1, const char *a2, ...);
int __fastcall sub_180001330(const char *a1, char *a2, unsigned int a3);
__int64 sub_1800014C0();
__int64 __fastcall guard_check_icall_nop(); // weak
char *GetVersionLib();
__int64 __fastcall InitBTConnection(void *Src); // idb
__int64 (__fastcall *UnloadDriverConnection())();
__int64 __fastcall GetLastApprovedTransactionStatus(__int64 a1);
__int64 __fastcall PPPAGSEGURO_PaymentTransaction(char a1, int a2, int a3, _BYTE *a4, char *a5, _BYTE *a6, void *a7);
__int64 __fastcall CancelTransaction(__int64 a1);
__int64 __fastcall SimplePaymentTransaction(char a1, int a2, int a3, char *a4, _BYTE *a5, void *a6);
__int64 __fastcall SetVersionName_0(_BYTE *Src, _BYTE *a2);
__int64 __fastcall sub_180002780(char *a1, char a2, int a3, int a4, void *a5, void *a6, _BYTE *a7);
__int64 __fastcall sub_180002D10(char *a1, __int16 a2);
int sub_180002F40(char *Buffer, size_t BufferCount, char *Format, ...);
void *__fastcall sub_180002FA0(int a1, void *a2);
__int64 __fastcall sub_180003160(char *a1);
__int64 __fastcall sub_1800031A0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, char *a5, __int64 a6, __int64 a7);
int __fastcall sub_1800032B0(__int64 a1);
__int64 __fastcall sub_180003530(__int64 a1, _BYTE *a2, _DWORD *a3);
__int64 __fastcall sub_180003730(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall sub_1800039A0(_BYTE *a1);
__int64 __fastcall sub_180003A30(__int64 a1, unsigned int *a2);
__int64 __fastcall sub_180003BA0(__int64 a1, __int64 a2);
void *__fastcall sub_180004030(void *Src, char *a2);
__int64 __fastcall sub_1800040F0(_BYTE *a1, __int16 a2);
char sub_180004714();
void sub_180004B38();
void __fastcall sub_180004B48();
void *sub_180004B54();
void *sub_180004B78();
__int64 sub_180004CC8();
void __fastcall sub_180004D14();
__int64 __fastcall j__guard_check_icall_nop(); // weak
// __int64 __fastcall _std_type_info_destroy_list(_QWORD); weak
// void *__cdecl memset(void *, int Val, size_t Size);
char sub_180004FA4();
__int64 sub_180004FA8();
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);

//-------------------------------------------------------------------------
// Data declarations

// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern void *(__cdecl *memmove)(void *, const void *Src, size_t Size);
// extern void *(__cdecl *malloc)(size_t Size);
// extern void (__cdecl *free)(void *Block);
// extern FILE *(__cdecl *_acrt_iob_func)(unsigned int Ix);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern int (__cdecl *_stdio_common_vsprintf)(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern errno_t (__cdecl *fopen_s)(FILE **Stream, const char *FileName, const char *Mode);
// extern int (__cdecl *_stdio_common_vfprintf)(unsigned __int64 Options, FILE *Stream, const char *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *isdigit)(int C);
// extern errno_t (__cdecl *localtime64_s)(struct tm *Tm, const __time64_t *Time);
// extern __time64_t (__cdecl *time64)(__time64_t *Time);
// extern size_t (__cdecl *strftime)(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);
char a0123456789abcd[17] = "0123456789ABCDEF"; // weak
char a0123456789abcd_0[22] = "0123456789ABCDEF1.1.0"; // weak
_UNKNOWN unk_180006480; // weak
_UNKNOWN unk_1800064A0; // weak
_UNKNOWN unk_1800064A4; // weak
_UNKNOWN unk_1800064A8; // weak
_QWORD qword_180006E28[2] = { 0LL, 0LL }; // weak
_QWORD qword_180006E38 = 0LL; // weak
char aComport[8] = "comport"; // weak
int dword_180008049 = 2; // weak
__int64 (__fastcall *SerialPortOpen[4])() = { &sub_1800014C0, &sub_1800014C0, &sub_1800014C0, &guard_check_icall_nop }; // weak
__int64 (__fastcall *SerialPortRead[3])() = { &sub_1800014C0, &sub_1800014C0, &guard_check_icall_nop }; // weak
__int64 (__fastcall *off_18000805D[2])() = { &sub_1800014C0, &guard_check_icall_nop }; // weak
__int64 (__fastcall *SerialPortClose)() = &guard_check_icall_nop; // weak
_UNKNOWN unk_180008070; // weak
union _SLIST_HEADER stru_1800086F0; // weak
_UNKNOWN unk_180008700; // weak
char Buffer; // idb
char qword_180008810[]; // idb
__int64 qword_180008818; // weak
__int64 qword_180008820; // weak
__int64 qword_180008828; // weak
__int64 qword_180008830; // weak
__int64 qword_180008838; // weak
__int64 qword_180008840; // weak
__int64 qword_180008848; // weak
char byte_180008850[]; // weak
char byte_180008860[]; // weak
_UNKNOWN unk_180008880; // weak
_UNKNOWN unk_180008888; // weak


//----- (0000000180001000) ----------------------------------------------------
void *sub_180001000()
{
  return &unk_180008888;
}

//----- (0000000180001010) ----------------------------------------------------
int sub_180001010(FILE *Stream, char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_180001000();
  return _stdio_common_vfprintf(*v4, Stream, Format, 0LL, va);
}

//----- (0000000180001060) ----------------------------------------------------
int sub_180001060(char *Format, ...)
{
  FILE *v2; // rbx
  unsigned __int64 *v3; // rax
  va_list va; // [rsp+58h] [rbp+10h] BYREF

  va_start(va, Format);
  v2 = _acrt_iob_func(1u);
  v3 = (unsigned __int64 *)sub_180001000();
  return _stdio_common_vfprintf(*v3, v2, Format, 0LL, va);
}

//----- (00000001800010C0) ----------------------------------------------------
const char *sub_1800010C0()
{
  __time64_t Time; // [rsp+20h] [rbp-48h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-40h] BYREF

  if ( Buffer )
    return &Buffer;
  Time = time64(0LL);
  localtime64_s(&Tm, &Time);
  if ( strftime(&Buffer, 0x100uLL, "PPPAGSEGURO_%Y-%m-%d.log", &Tm) )
    return &Buffer;
  memset(&Buffer, 0, 0x100uLL);
  return "PPPAGSEGURO.log";
}

//----- (0000000180001170) ----------------------------------------------------
char *sub_180001170()
{
  __time64_t Time; // [rsp+20h] [rbp-48h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-40h] BYREF

  Time = time64(0LL);
  localtime64_s(&Tm, &Time);
  if ( strftime(qword_180008810, 0x40uLL, "%H:%M:%S|", &Tm) )
    return qword_180008810;
  *(_QWORD *)qword_180008810 = 0LL;
  qword_180008818 = 0LL;
  qword_180008820 = 0LL;
  qword_180008828 = 0LL;
  qword_180008830 = 0LL;
  qword_180008838 = 0LL;
  qword_180008840 = 0LL;
  qword_180008848 = 0LL;
  return "00:00:00|";
}
// 180008818: using guessed type __int64 qword_180008818;
// 180008820: using guessed type __int64 qword_180008820;
// 180008828: using guessed type __int64 qword_180008828;
// 180008830: using guessed type __int64 qword_180008830;
// 180008838: using guessed type __int64 qword_180008838;
// 180008840: using guessed type __int64 qword_180008840;
// 180008848: using guessed type __int64 qword_180008848;

//----- (0000000180001230) ----------------------------------------------------
int sub_180001230(int a1, const char *a2, ...)
{
  char *v3; // rsi
  const char *v4; // rax
  FILE *v5; // rdi
  unsigned __int64 *v6; // rax
  FILE *v7; // rbx
  unsigned __int64 *v8; // rax
  FILE *Stream; // [rsp+30h] [rbp-38h] BYREF
  va_list va; // [rsp+80h] [rbp+18h] BYREF

  va_start(va, a2);
  v3 = sub_180001170();
  v4 = sub_1800010C0();
  fopen_s(&Stream, v4, "a+");
  v5 = Stream;
  if ( Stream )
  {
    if ( a1 )
    {
      sub_180001010(Stream, "%s", v3);
      v5 = Stream;
    }
    v6 = (unsigned __int64 *)sub_180001000();
    _stdio_common_vfprintf(*v6, v5, a2, 0LL, va);
    fflush(Stream);
    fclose(Stream);
  }
  if ( a1 )
    sub_180001060("%s", v3);
  v7 = _acrt_iob_func(1u);
  v8 = (unsigned __int64 *)sub_180001000();
  return _stdio_common_vfprintf(*v8, v7, a2, 0LL, va);
}

//----- (0000000180001330) ----------------------------------------------------
int __fastcall sub_180001330(const char *a1, char *a2, unsigned int a3)
{
  char *v4; // rsi
  __int64 v5; // rbx
  unsigned int v6; // edi
  char v7; // r9
  int v8; // r8d
  __int64 v9; // rdx
  int result; // eax
  char v11[112]; // [rsp+20h] [rbp-108h] BYREF
  char v12[112]; // [rsp+90h] [rbp-98h] BYREF

  if ( a2 )
  {
    v4 = a2;
    if ( a3 )
    {
      sub_180001230(
        0,
        "[%s]:\n"
        "0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F |0123456789ABCDEF|\n"
        "------------------------------------------------------------------\n",
        a1);
      v5 = 0LL;
      memset(v11, 32, 0x64uLL);
      memset(v12, 0, 0x64uLL);
      v6 = 0;
      do
      {
        v7 = *v4;
        v8 = 3 * v5;
        v9 = *v4 & 0xF;
        v11[(unsigned int)(3 * v5)] = a0123456789abcd[(unsigned __int64)(unsigned __int8)*v4 >> 4];
        v11[v8 + 1] = a0123456789abcd[v9];
        v11[v8 + 2] = 32;
        if ( (unsigned __int8)(v7 - 32) > 0x5Eu )
          v12[v5] = 46;
        else
          v12[v5] = v7;
        v5 = (unsigned int)(v5 + 1);
        if ( (_DWORD)v5 == 16 || v6 + 1 == a3 )
        {
          v11[47] = 0;
          sub_180001230(0, "%s |%-16s|\n", v11, v12);
          v5 = 0LL;
          memset(v11, 32, 0x64uLL);
          memset(v12, 0, 0x64uLL);
        }
        ++v6;
        ++v4;
      }
      while ( v6 < a3 );
      return sub_180001230(0, "------------------------------------------------------------------\n");
    }
  }
  return result;
}
// 180001330: using guessed type char var_98[112];

//----- (00000001800014C0) ----------------------------------------------------
__int64 sub_1800014C0()
{
  return 4294966286LL;
}

//----- (00000001800014E0) ----------------------------------------------------
char *GetVersionLib()
{
  return "1.1.0";
}

//----- (00000001800014F0) ----------------------------------------------------
__int64 __fastcall InitBTConnection(void *Src)
{
  HMODULE LibraryA; // rax
  HMODULE v2; // rbx
  __int64 result; // rax

  memmove(aComport, Src, 9uLL);
  dword_180008049 = 2;
  LibraryA = LoadLibraryA("BTSerial.dll");
  v2 = LibraryA;
  if ( !LibraryA )
    return 4294966286LL;
  SerialPortOpen[0] = GetProcAddress(LibraryA, "SerialPortOpen");
  if ( !SerialPortOpen[0] )
    return 4294966285LL;
  SerialPortClose = GetProcAddress(v2, "SerialPortClose");
  if ( !SerialPortClose )
    return 4294966285LL;
  SerialPortRead[0] = GetProcAddress(v2, "SerialPortRead");
  if ( !SerialPortRead[0] )
    return 4294966285LL;
  result = (__int64)GetProcAddress(v2, "SerialPortWrite");
  off_18000805D[0] = (__int64 (__fastcall *)())result;
  if ( !result )
    return 4294966285LL;
  return result;
}
// 180008049: using guessed type int dword_180008049;
// 18000804D: using guessed type __int64 (__fastcall *SerialPortOpen[4])();
// 180008055: using guessed type __int64 (__fastcall *SerialPortRead[3])();
// 18000805D: using guessed type __int64 (__fastcall *off_18000805D[2])();
// 180008065: using guessed type __int64 (__fastcall *SerialPortClose)();

//----- (00000001800015C0) ----------------------------------------------------
__int64 (__fastcall *UnloadDriverConnection())()
{
  __int64 (__fastcall *result)(); // rax

  memset(aComport, 32, 9);
  SerialPortOpen[0] = sub_1800014C0;
  SerialPortRead[0] = sub_1800014C0;
  off_18000805D[0] = sub_1800014C0;
  result = guard_check_icall_nop;
  SerialPortClose = guard_check_icall_nop;
  return result;
}
// 1800014D0: using guessed type __int64 __fastcall guard_check_icall_nop();
// 18000804D: using guessed type __int64 (__fastcall *SerialPortOpen[4])();
// 180008055: using guessed type __int64 (__fastcall *SerialPortRead[3])();
// 18000805D: using guessed type __int64 (__fastcall *off_18000805D[2])();
// 180008065: using guessed type __int64 (__fastcall *SerialPortClose)();

//----- (0000000180001610) ----------------------------------------------------
__int64 __fastcall GetLastApprovedTransactionStatus(__int64 a1)
{
  char v2; // r12
  unsigned int v4; // r15d
  int v5; // edi
  unsigned int v6; // ebx
  char *v7; // rdi
  int v8; // eax
  unsigned __int8 v9; // dl
  unsigned __int8 v10; // si
  _DWORD *v11; // rbx
  size_t v12; // rbx
  void *v13; // rsi
  unsigned int v14; // [rsp+30h] [rbp-D0h] BYREF
  char v15[2]; // [rsp+38h] [rbp-C8h] BYREF
  unsigned __int16 v16; // [rsp+3Ah] [rbp-C6h]
  void *Buf1; // [rsp+3Ch] [rbp-C4h]
  _DWORD v18[152]; // [rsp+50h] [rbp-B0h] BYREF
  char Src[65552]; // [rsp+2B0h] [rbp+1B0h] BYREF

  v2 = 0;
  memset(Src, 0, 0x10006uLL);
  if ( !a1 )
    return 4294966287LL;
  memset((void *)a1, 0, 0x104C1uLL);
  v4 = 0;
  v5 = sub_180002D10((char *)v18, 352);
  if ( !v5 )
  {
    v14 = 65542;
    sub_180001230(0, "%s\n", "Conectando serial (bt)...");
    v5 = SerialPortOpen[0]();
    if ( !v5 )
    {
      sub_180001230(0, "%s\n", "Enviando msg...");
      sub_1800032B0((__int64)v18);
      v5 = sub_180003530((__int64)v18, Src, &v14);
      if ( !v5 )
      {
        v6 = v14;
        sub_180001330("msg_buffer", Src, v14);
        v7 = Src;
        do
        {
          v8 = off_18000805D[0]();
          if ( v8 < 0 )
            goto LABEL_15;
          v6 -= v8;
          v7 += v6;
        }
        while ( v6 );
        v5 = sub_1800039A0(v18);
        if ( !v5 )
        {
          memset(Src, 0, 0x10006uLL);
          sub_180001230(1, "TRACE|%s:%d|%s\n", "GetLastApprovedTransactionStatus", 207LL, "Passou MessageDestroy");
          v14 = 65542;
          v5 = sub_180003A30((__int64)Src, &v14);
          if ( v5 >= 0 )
          {
            sub_180001230(1, "TRACE|%s:%d|%s\n", "GetLastApprovedTransactionStatus", 212LL, "Passou MessageReceive");
            v5 = sub_180003730((__int64)v18, (unsigned __int8 *)Src);
            if ( !v5 )
            {
              v9 = 0;
              if ( !LOBYTE(v18[151]) )
              {
LABEL_15:
                v5 = -1999;
                goto LABEL_16;
              }
              while ( LOWORD(v18[3 * v9 + 1]) != 1 )
              {
                if ( ++v9 >= LOBYTE(v18[151]) )
                  goto LABEL_15;
              }
              memmove(v15, &v18[3 * v9 + 1], 0xCuLL);
              v5 = 0;
              sub_180001330("msg_field.value", (char *)Buf1, v16);
              if ( memcmp(Buf1, &unk_180006480, v16) )
              {
                sub_180001230(0, "%s\n", "Transacao Finalizada!");
                sub_1800032B0((__int64)v18);
                v12 = v16;
                v13 = Buf1;
                if ( !memcmp(Buf1, &unk_1800064A0, v16) )
                {
                  v2 = 1;
                  sub_180003BA0((__int64)v18, a1);
                }
                else if ( !memcmp(v13, &unk_1800064A4, v12) )
                {
                  v5 = -1018;
                }
                else
                {
                  v5 = -1004;
                  if ( !memcmp(v13, &unk_1800064A8, v12) )
                    v5 = -1019;
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_16:
  SerialPortClose();
  v10 = 0;
  if ( LOBYTE(v18[151]) )
  {
    while ( 1 )
    {
      v11 = &v18[3 * v10 + 1];
      if ( !v11 )
        break;
      free(*(void **)(v11 + 1));
      ++v10;
      *(_QWORD *)v11 = 0LL;
      v11[2] = 0;
      if ( v10 >= LOBYTE(v18[151]) )
        goto LABEL_19;
    }
  }
  else
  {
LABEL_19:
    memset(v18, 0, 0x25DuLL);
  }
  sub_180002FA0(v5, (void *)(a1 + 65543));
  memmove((void *)a1, Src, 0x10006uLL);
  if ( v2 != 1 )
    return (unsigned int)v5;
  return v4;
}
// 18000804D: invalid function type '?' has been ignored
// 18000805D: invalid function type '?' has been ignored
// 1800014D0: using guessed type __int64 __fastcall guard_check_icall_nop();
// 18000804D: using guessed type __int64 (__fastcall *SerialPortOpen[4])();
// 18000805D: using guessed type __int64 (__fastcall *off_18000805D[2])();
// 180008065: using guessed type __int64 (__fastcall *SerialPortClose)();
// 180001610: using guessed type char var_102B8[2];

//----- (0000000180001A00) ----------------------------------------------------
__int64 __fastcall PPPAGSEGURO_PaymentTransaction(char a1, int a2, int a3, _BYTE *a4, char *a5, _BYTE *a6, void *a7)
{
  unsigned int v7; // r14d
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  int v14; // ebx
  unsigned int v15; // ebx
  char *v16; // rdi
  int v17; // eax
  unsigned __int8 v18; // dl
  char *v19; // r15
  unsigned __int8 v20; // si
  _DWORD *v21; // rdi
  char v22; // si
  unsigned int v23; // ebx
  char *v24; // rdi
  int v25; // eax
  unsigned __int8 v26; // dl
  size_t v27; // rdi
  void *v28; // rsi
  __int64 result; // rax
  void *v30; // [rsp+28h] [rbp-D8h]
  void *v31; // [rsp+28h] [rbp-D8h]
  unsigned int v32; // [rsp+40h] [rbp-C0h] BYREF
  char v33; // [rsp+44h] [rbp-BCh]
  char v34; // [rsp+45h] [rbp-BBh]
  void *v35; // [rsp+48h] [rbp-B8h]
  int v36; // [rsp+50h] [rbp-B0h]
  char v37[2]; // [rsp+58h] [rbp-A8h] BYREF
  unsigned __int16 v38; // [rsp+5Ah] [rbp-A6h]
  void *Buf1; // [rsp+5Ch] [rbp-A4h]
  _DWORD v40[152]; // [rsp+70h] [rbp-90h] BYREF
  char Src[65552]; // [rsp+2D0h] [rbp+1D0h] BYREF

  v7 = 65542;
  v36 = a3;
  v35 = a7;
  v34 = 0;
  v32 = 65542;
  memset(Src, 0, 0x10006uLL);
  memset(a7, 0, 0x104C1uLL);
  v14 = sub_1800031A0(v12, v11, v13, a4, a5, (__int64)a6, (__int64)a7);
  if ( v14 )
  {
    v19 = (char *)v35;
    goto LABEL_47;
  }
  v14 = sub_180002780((char *)v40, a1, a2, v36, a4, a5, a6);
  if ( v14 )
    goto LABEL_15;
  v14 = sub_180003530((__int64)v40, Src, &v32);
  if ( v14 )
    goto LABEL_44;
  sub_180001230(0, "%s\n", "Conectando serial (bt)...");
  v14 = SerialPortOpen[0]();
  if ( v14 )
    goto LABEL_44;
  sub_180001230(0, "%s\n", "Enviando msg...");
  sub_1800032B0((__int64)v40);
  v7 = v32;
  v15 = v32;
  sub_180001330("msg_buffer", Src, v32);
  v16 = Src;
  do
  {
    v17 = off_18000805D[0]();
    if ( v17 < 0 )
      goto LABEL_14;
    v15 -= v17;
    v16 += v15;
  }
  while ( v15 );
  v14 = sub_1800039A0(v40);
  if ( v14 )
    goto LABEL_15;
  v32 = 65542;
  memset(Src, 0, 0x10006uLL);
  LODWORD(v30) = sub_180003A30((__int64)Src, &v32);
  v14 = (int)v30;
  sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "PPPAGSEGURO_PaymentTransaction", 332LL, "ret_code", v30);
  if ( v14 < 0 )
  {
LABEL_44:
    v19 = (char *)v35;
  }
  else
  {
    v7 = v32;
    LODWORD(v31) = v32;
    sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "PPPAGSEGURO_PaymentTransaction", 335LL, "buffer_size", v31);
    sub_180001230(0, "%s\n", "Resposta OK.");
    v14 = sub_180003730((__int64)v40, (unsigned __int8 *)Src);
    if ( v14 )
      goto LABEL_15;
    v18 = 0;
    if ( !LOBYTE(v40[151]) )
    {
LABEL_14:
      v14 = -1999;
      goto LABEL_15;
    }
    while ( LOWORD(v40[3 * v18 + 1]) != 2561 )
    {
      if ( ++v18 >= LOBYTE(v40[151]) )
        goto LABEL_14;
    }
    memmove(v37, &v40[3 * v18 + 1], 0xCuLL);
    if ( *(_BYTE *)Buf1 )
    {
      v14 = -1003;
LABEL_15:
      v19 = (char *)v35;
      goto LABEL_16;
    }
    sub_1800039A0(v40);
    v19 = (char *)v35;
    v22 = 0;
    while ( 2 )
    {
      sub_180001230(0, "%s\n", "Aguardando transacao...");
      Sleep(1000 * dword_180008049);
      memset(Src, 0, 0x10006uLL);
      v14 = sub_180002D10((char *)v40, 514);
      if ( v14 )
        goto LABEL_16;
      v32 = 65542;
      v14 = sub_180003530((__int64)v40, Src, &v32);
      if ( !v14 )
      {
        v7 = v32;
        v23 = v32;
        sub_180001330("msg_buffer", Src, v32);
        v24 = Src;
        do
        {
          v25 = off_18000805D[0]();
          if ( v25 < 0 )
          {
            v14 = -1999;
            goto LABEL_16;
          }
          v23 -= v25;
          v24 += v23;
        }
        while ( v23 );
        v14 = sub_1800039A0(v40);
        if ( v14 )
          goto LABEL_16;
        memset(Src, 0, 0x10006uLL);
        sub_180001230(1, "TRACE|%s:%d|%s\n", "PPPAGSEGURO_PaymentTransaction", 373LL, "Passou MessageDestroy");
        v32 = 65542;
        v14 = sub_180003A30((__int64)Src, &v32);
        if ( v14 >= 0 )
        {
          sub_180001230(1, "TRACE|%s:%d|%s\n", "PPPAGSEGURO_PaymentTransaction", 378LL, "Passou MessageReceive");
          v14 = sub_180003730((__int64)v40, (unsigned __int8 *)Src);
          if ( !v14 )
          {
            v26 = 0;
            if ( !LOBYTE(v40[151]) )
            {
LABEL_34:
              v7 = v32;
              v14 = -1999;
              goto LABEL_16;
            }
            while ( LOWORD(v40[3 * v26 + 1]) != 1 )
            {
              if ( ++v26 >= LOBYTE(v40[151]) )
                goto LABEL_34;
            }
            memmove(v37, &v40[3 * v26 + 1], 0xCuLL);
            v14 = 0;
            sub_180001330("msg_field.value", (char *)Buf1, v38);
            if ( memcmp(Buf1, &unk_180006480, v38) )
            {
              sub_180001230(0, "%s\n", "Transacao Finalizada!");
              sub_1800032B0((__int64)v40);
              v27 = v38;
              v28 = Buf1;
              v33 = 1;
              if ( !memcmp(Buf1, &unk_1800064A0, v38) )
              {
                v34 = 1;
                sub_180003BA0((__int64)v40, (__int64)v19);
              }
              else
              {
                v14 = -1004;
                if ( !memcmp(v28, &unk_1800064A8, v27) )
                  v14 = -1019;
              }
              v22 = v33;
            }
            sub_1800039A0(v40);
            if ( !v22 )
            {
              v7 = v32;
              continue;
            }
          }
        }
      }
      break;
    }
  }
  v7 = v32;
LABEL_16:
  SerialPortClose();
  v20 = 0;
  if ( LOBYTE(v40[151]) )
  {
    while ( 1 )
    {
      v21 = &v40[3 * v20 + 1];
      if ( !v21 )
        break;
      free(*(void **)(v21 + 1));
      ++v20;
      *(_QWORD *)v21 = 0LL;
      v21[2] = 0;
      if ( v20 >= LOBYTE(v40[151]) )
        goto LABEL_19;
    }
  }
  else
  {
LABEL_19:
    memset(v40, 0, 0x25DuLL);
  }
LABEL_47:
  sub_180002FA0(v14, v19 + 65543);
  memmove(v19, Src, v7);
  result = 0LL;
  if ( v34 != 1 )
    return (unsigned int)v14;
  return result;
}
// 18000804D: invalid function type '__int64 (__fastcall *SerialPortOpen[4])()' has been ignored
// 18000805D: invalid function type '__int64 (__fastcall *off_18000805D[2])()' has been ignored
// 180001A9E: variable 'v12' is possibly undefined
// 180001A9E: variable 'v11' is possibly undefined
// 180001A9E: variable 'v13' is possibly undefined
// 180001BFA: variable 'v30' is possibly undefined
// 180001C36: variable 'v31' is possibly undefined
// 1800014D0: using guessed type __int64 __fastcall guard_check_icall_nop();
// 180008049: using guessed type int dword_180008049;
// 18000804D: using guessed type __int64 (__fastcall *SerialPortOpen[4])();
// 18000805D: using guessed type __int64 (__fastcall *off_18000805D[2])();
// 180008065: using guessed type __int64 (__fastcall *SerialPortClose)();

//----- (0000000180002070) ----------------------------------------------------
__int64 __fastcall CancelTransaction(__int64 a1)
{
  char v2; // r15
  char v3; // r13
  unsigned int v5; // r12d
  int v6; // ebx
  unsigned int v7; // ebx
  char *v8; // rdi
  int v9; // eax
  unsigned __int8 v10; // dl
  unsigned __int8 v11; // si
  _DWORD *v12; // rdi
  unsigned int v13; // ebx
  char *v14; // rdi
  int v15; // eax
  unsigned __int8 v16; // dl
  size_t v17; // rdi
  void *v18; // rsi
  __int64 v19; // [rsp+28h] [rbp-D8h]
  unsigned int v20; // [rsp+30h] [rbp-D0h] BYREF
  char v21[2]; // [rsp+38h] [rbp-C8h] BYREF
  unsigned __int16 v22; // [rsp+3Ah] [rbp-C6h]
  void *Buf1; // [rsp+3Ch] [rbp-C4h]
  _DWORD v24[152]; // [rsp+50h] [rbp-B0h] BYREF
  char Src[65552]; // [rsp+2B0h] [rbp+1B0h] BYREF

  v20 = 65542;
  v2 = 0;
  v3 = 0;
  memset(Src, 0, 0x10006uLL);
  if ( !a1 )
    return 4294966287LL;
  memset((void *)a1, 0, 0x104C1uLL);
  v5 = 0;
  v6 = sub_180002D10((char *)v24, 1024);
  if ( !v6 )
  {
    v6 = sub_180003530((__int64)v24, Src, &v20);
    if ( !v6 )
    {
      sub_180001230(0, "%s\n", "Conectando serial (bt)...");
      v6 = SerialPortOpen[0]();
      if ( !v6 )
      {
        sub_180001230(0, "%s\n", "Enviando msg...");
        sub_1800032B0((__int64)v24);
        v7 = v20;
        sub_180001330("msg_buffer", Src, v20);
        v8 = Src;
        do
        {
          v9 = off_18000805D[0]();
          if ( v9 < 0 )
            goto LABEL_15;
          v7 -= v9;
          v8 += v7;
        }
        while ( v7 );
        v6 = sub_1800039A0(v24);
        if ( !v6 )
        {
          v20 = 65542;
          memset(Src, 0, 0x10006uLL);
          v6 = sub_180003A30((__int64)Src, &v20);
          sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "CancelTransaction", 476LL, "ret_code", v6);
          if ( v6 >= 0 )
          {
            LODWORD(v19) = v20;
            sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "CancelTransaction", 479LL, "buffer_size", v19);
            sub_180001230(0, "%s\n", "Resposta OK.");
            v6 = sub_180003730((__int64)v24, (unsigned __int8 *)Src);
            if ( !v6 )
            {
              v10 = 0;
              if ( LOBYTE(v24[151]) )
              {
                while ( LOWORD(v24[3 * v10 + 1]) != 2561 )
                {
                  if ( ++v10 >= LOBYTE(v24[151]) )
                    goto LABEL_15;
                }
                memmove(v21, &v24[3 * v10 + 1], 0xCuLL);
                if ( *(_BYTE *)Buf1 )
                {
                  v6 = -1003;
                  goto LABEL_16;
                }
                sub_1800039A0(v24);
LABEL_26:
                sub_180001230(0, "%s\n", "Aguardando transacao...");
                Sleep(1000 * dword_180008049);
                memset(Src, 0, 0x10006uLL);
                v6 = sub_180002D10((char *)v24, 514);
                if ( v6 )
                  goto LABEL_16;
                v20 = 65542;
                v6 = sub_180003530((__int64)v24, Src, &v20);
                if ( v6 )
                  goto LABEL_16;
                v13 = v20;
                sub_180001330("msg_buffer", Src, v20);
                v14 = Src;
                while ( 1 )
                {
                  v15 = off_18000805D[0]();
                  if ( v15 < 0 )
                    break;
                  v13 -= v15;
                  v14 += v13;
                  if ( !v13 )
                  {
                    v6 = sub_1800039A0(v24);
                    if ( !v6 )
                    {
                      memset(Src, 0, 0x10006uLL);
                      sub_180001230(1, "TRACE|%s:%d|%s\n", "CancelTransaction", 517LL, "Passou MessageDestroy");
                      v20 = 65542;
                      v6 = sub_180003A30((__int64)Src, &v20);
                      if ( v6 >= 0 )
                      {
                        sub_180001230(1, "TRACE|%s:%d|%s\n", "CancelTransaction", 522LL, "Passou MessageReceive");
                        v6 = sub_180003730((__int64)v24, (unsigned __int8 *)Src);
                        if ( !v6 )
                        {
                          v16 = 0;
                          if ( !LOBYTE(v24[151]) )
                            break;
                          while ( LOWORD(v24[3 * v16 + 1]) != 1 )
                          {
                            if ( ++v16 >= LOBYTE(v24[151]) )
                              goto LABEL_15;
                          }
                          memmove(v21, &v24[3 * v16 + 1], 0xCuLL);
                          v6 = 0;
                          sub_180001330("msg_field.value", (char *)Buf1, v22);
                          if ( memcmp(Buf1, &unk_180006480, v22) )
                          {
                            sub_180001230(0, "%s\n", "Transacao Finalizada!");
                            sub_1800032B0((__int64)v24);
                            v17 = v22;
                            v18 = Buf1;
                            v2 = 1;
                            if ( !memcmp(Buf1, &unk_1800064A0, v22) )
                            {
                              v3 = 1;
                              sub_180003BA0((__int64)v24, a1);
                            }
                            else
                            {
                              v6 = -1004;
                              if ( !memcmp(v18, &unk_1800064A8, v17) )
                                v6 = -1019;
                            }
                          }
                          sub_1800039A0(v24);
                          if ( !v2 )
                            goto LABEL_26;
                        }
                      }
                    }
                    goto LABEL_16;
                  }
                }
              }
LABEL_15:
              v6 = -1999;
            }
          }
        }
      }
    }
  }
LABEL_16:
  SerialPortClose();
  v11 = 0;
  if ( LOBYTE(v24[151]) )
  {
    while ( 1 )
    {
      v12 = &v24[3 * v11 + 1];
      if ( !v12 )
        break;
      free(*(void **)(v12 + 1));
      ++v11;
      *(_QWORD *)v12 = 0LL;
      v12[2] = 0;
      if ( v11 >= LOBYTE(v24[151]) )
        goto LABEL_19;
    }
  }
  else
  {
LABEL_19:
    memset(v24, 0, 0x25DuLL);
  }
  sub_180002FA0(v6, (void *)(a1 + 65543));
  memmove((void *)a1, Src, 0x10006uLL);
  if ( v3 != 1 )
    return (unsigned int)v6;
  return v5;
}
// 18000804D: invalid function type '__int64 (__fastcall *SerialPortOpen[4])()' has been ignored
// 18000805D: invalid function type '__int64 (__fastcall *off_18000805D[2])()' has been ignored
// 180002274: variable 'v19' is possibly undefined
// 1800014D0: using guessed type __int64 __fastcall guard_check_icall_nop();
// 180008049: using guessed type int dword_180008049;
// 18000804D: using guessed type __int64 (__fastcall *SerialPortOpen[4])();
// 18000805D: using guessed type __int64 (__fastcall *off_18000805D[2])();
// 180008065: using guessed type __int64 (__fastcall *SerialPortClose)();

//----- (00000001800026A0) ----------------------------------------------------
__int64 __fastcall SimplePaymentTransaction(char a1, int a2, int a3, char *a4, _BYTE *a5, void *a6)
{
  return PPPAGSEGURO_PaymentTransaction(a1, a2, a3, a4, a4, a5, a6);
}

//----- (00000001800026E0) ----------------------------------------------------
__int64 __fastcall SetVersionName_0(_BYTE *Src, _BYTE *a2)
{
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // r8

  if ( !Src || !a2 )
    return 4294966294LL;
  v3 = -1LL;
  v4 = -1LL;
  do
    ++v4;
  while ( Src[v4] );
  if ( v4 >= 0x1A )
    return 4294966281LL;
  do
    ++v3;
  while ( a2[v3] );
  if ( v3 >= 0xB )
    return 4294966280LL;
  memmove(byte_180008860, Src, 0x1AuLL);
  memmove(byte_180008850, a2, 0xBuLL);
  return 0LL;
}

//----- (0000000180002780) ----------------------------------------------------
__int64 __fastcall sub_180002780(char *a1, char a2, int a3, int a4, void *a5, void *a6, _BYTE *a7)
{
  int v11; // ecx
  void *v12; // rax
  void *v13; // rax
  __int64 v14; // rbx
  __int64 v15; // rax
  unsigned int v16; // edi
  void *v17; // rax
  __int64 v18; // rax
  unsigned int v19; // edi
  void *v20; // rax
  void *v21; // rax
  void *v22; // rax
  void *v23; // rax
  __int64 v24; // rax
  unsigned int v25; // edi
  void *v26; // rax
  __int64 v27; // rax
  unsigned int v28; // edi
  void *v29; // rax
  void *v30; // rax
  __int64 Src[2]; // [rsp+20h] [rbp-50h] BYREF
  char v33; // [rsp+30h] [rbp-40h] BYREF
  char v34; // [rsp+31h] [rbp-3Fh] BYREF
  char v35[6]; // [rsp+32h] [rbp-3Eh] BYREF
  char v36[24]; // [rsp+38h] [rbp-38h] BYREF
  char v37[24]; // [rsp+50h] [rbp-20h] BYREF

  memset(a1, 0, 0x25DuLL);
  v33 = a2;
  v34 = a3;
  v11 = a4 % 10;
  if ( a4 >= 10 )
    LOBYTE(v11) = 16 * (a4 / 10) + v11;
  v35[0] = v11;
  if ( !a1 )
    return 4294966294LL;
  memset(a1, 0, 0x25DuLL);
  *(_DWORD *)a1 = 33554433;
  LODWORD(Src[0]) = 327705;
  a1[604] = 0;
  v12 = malloc(5uLL);
  *(__int64 *)((char *)Src + 4) = (__int64)v12;
  if ( !v12 )
    return 1LL;
  memmove(v12, "1.1.0", 5uLL);
  memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
  ++a1[604];
  Src[0] = 65741LL;
  LODWORD(Src[1]) = 0;
  v13 = malloc(1uLL);
  *(__int64 *)((char *)Src + 4) = (__int64)v13;
  if ( !v13 )
    return 1LL;
  memmove(v13, "1", 1uLL);
  memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
  ++a1[604];
  if ( !byte_180008860[0] )
    return 4294966279LL;
  v14 = -1LL;
  memset(Src, 0, 12);
  v15 = -1LL;
  do
    ++v15;
  while ( byte_180008860[v15] );
  v16 = (unsigned __int16)v15;
  LOWORD(Src[0]) = 206;
  WORD1(Src[0]) = v15;
  v17 = malloc((unsigned __int16)v15);
  *(__int64 *)((char *)Src + 4) = (__int64)v17;
  if ( !v17 )
    return 1LL;
  memmove(v17, byte_180008860, v16);
  memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
  ++a1[604];
  if ( !byte_180008850[0] )
    return 4294966279LL;
  memset(Src, 0, 12);
  v18 = -1LL;
  do
    ++v18;
  while ( byte_180008850[v18] );
  v19 = (unsigned __int16)v18;
  LOWORD(Src[0]) = 207;
  WORD1(Src[0]) = v18;
  v20 = malloc((unsigned __int16)v18);
  *(__int64 *)((char *)Src + 4) = (__int64)v20;
  if ( !v20 )
    return 1LL;
  memmove(v20, byte_180008850, v19);
  memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
  ++a1[604];
  Src[0] = 65585LL;
  LODWORD(Src[1]) = 0;
  v21 = malloc(1uLL);
  *(__int64 *)((char *)Src + 4) = (__int64)v21;
  if ( !v21 )
    return 1LL;
  memmove(v21, &v33, 1uLL);
  memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
  ++a1[604];
  Src[0] = 65569LL;
  LODWORD(Src[1]) = 0;
  v22 = malloc(1uLL);
  *(__int64 *)((char *)Src + 4) = (__int64)v22;
  if ( !v22 )
    return 1LL;
  memmove(v22, &v34, 1uLL);
  memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
  ++a1[604];
  Src[0] = 65570LL;
  LODWORD(Src[1]) = 0;
  v23 = malloc(1uLL);
  *(__int64 *)((char *)Src + 4) = (__int64)v23;
  if ( !v23 )
    return 1LL;
  memmove(v23, v35, 1uLL);
  memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
  ++a1[604];
  sub_180004030(a6, v36);
  memset(Src, 0, 12);
  v24 = -1LL;
  do
    ++v24;
  while ( v36[v24] );
  v25 = (unsigned __int16)v24;
  LOWORD(Src[0]) = 36;
  WORD1(Src[0]) = v24;
  v26 = malloc((unsigned __int16)v24);
  *(__int64 *)((char *)Src + 4) = (__int64)v26;
  if ( !v26 )
    return 1LL;
  memmove(v26, v36, v25);
  memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
  ++a1[604];
  if ( a3 == 3 )
  {
    sub_180004030(a5, v37);
    memset(Src, 0, 12);
    v27 = -1LL;
    do
      ++v27;
    while ( v37[v27] );
    v28 = (unsigned __int16)v27;
    LOWORD(Src[0]) = 35;
    WORD1(Src[0]) = v27;
    v29 = malloc((unsigned __int16)v27);
    *(__int64 *)((char *)Src + 4) = (__int64)v29;
    if ( v29 )
    {
      memmove(v29, v37, v28);
      memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
      ++a1[604];
      goto LABEL_25;
    }
    return 1LL;
  }
LABEL_25:
  if ( a7 )
  {
    memset(Src, 0, 12);
    do
      ++v14;
    while ( a7[v14] );
    WORD1(Src[0]) = v14;
    LOWORD(Src[0]) = 71;
    v30 = malloc((unsigned __int16)v14);
    *(__int64 *)((char *)Src + 4) = (__int64)v30;
    if ( v30 )
      memmove(v30, a7, (unsigned __int16)v14);
    memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
    ++a1[604];
  }
  return 0LL;
}
// 180002780: using guessed type char var_3E[6];
// 180002780: using guessed type char var_38[24];
// 180002780: using guessed type char var_20[24];

//----- (0000000180002D10) ----------------------------------------------------
__int64 __fastcall sub_180002D10(char *a1, __int16 a2)
{
  void *v4; // rax
  __int64 result; // rax
  void *v6; // rax
  __int64 v7; // rax
  unsigned int v8; // edi
  void *v9; // rax
  char v10[8]; // [rsp+20h] [rbp-28h] BYREF
  __int64 Src[2]; // [rsp+28h] [rbp-20h] BYREF

  memset(a1, 0, 0x25DuLL);
  if ( a1 )
  {
    memset(a1, 0, 0x25DuLL);
    *(_WORD *)a1 = 1;
    *((_WORD *)a1 + 1) = a2;
    a1[604] = 0;
  }
  LODWORD(Src[0]) = 327705;
  v4 = malloc(5uLL);
  *(__int64 *)((char *)Src + 4) = (__int64)v4;
  if ( v4 )
    memmove(v4, "1.1.0", 5uLL);
  if ( a1 )
  {
    memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
    ++a1[604];
    result = 0LL;
  }
  else
  {
    result = 4294966294LL;
  }
  if ( a2 == 1024 )
  {
    v10[0] = 99;
    Src[0] = 65585LL;
    LODWORD(Src[1]) = 0;
    v6 = malloc(1uLL);
    *(__int64 *)((char *)Src + 4) = (__int64)v6;
    if ( !v6 )
      return 1LL;
    memmove(v6, v10, 1uLL);
    if ( !a1 )
      return 4294966294LL;
    memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
    ++a1[604];
    if ( !byte_180008860[0] )
      return 4294966279LL;
    memset(Src, 0, 12);
    v7 = -1LL;
    do
      ++v7;
    while ( byte_180008860[v7] );
    v8 = (unsigned __int16)v7;
    LOWORD(Src[0]) = 206;
    WORD1(Src[0]) = v7;
    v9 = malloc((unsigned __int16)v7);
    *(__int64 *)((char *)Src + 4) = (__int64)v9;
    if ( !v9 )
      return 1LL;
    memmove(v9, byte_180008860, v8);
    memmove(&a1[8 * (unsigned __int8)a1[604] + 4 + 4 * (unsigned __int8)a1[604]], Src, 0xCuLL);
    ++a1[604];
  }
  else if ( (_DWORD)result )
  {
    return result;
  }
  return 0LL;
}
// 180002D10: using guessed type char var_28[8];

//----- (0000000180002F40) ----------------------------------------------------
int sub_180002F40(char *Buffer, size_t BufferCount, char *Format, ...)
{
  _QWORD *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = sub_180001000();
  result = _stdio_common_vsprintf(*v6 | 2LL, Buffer, BufferCount, Format, 0LL, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (0000000180002FA0) ----------------------------------------------------
void *__fastcall sub_180002FA0(int a1, void *a2)
{
  int v3; // ecx
  void *result; // rax
  const char *v5; // rdx

  if ( a1 <= 0 )
  {
    if ( a1 )
    {
      v3 = a1 + 1019;
      result = (void *)v3;
      switch ( v3 )
      {
        case 0:
          result = memmove(a2, "Erro de comunicacao, realize consulta para verificacao", 0x36uLL);
          break;
        case 1:
          result = memmove(a2, "Sem dados para consulta", 0x17uLL);
          break;
        case 6:
          result = memmove(a2, "Parametro de codigo de venda muito grande", 0x29uLL);
          break;
        case 7:
          result = memmove(a2, "Parametro de valor da transacao invalido", 0x28uLL);
          break;
        case 10:
          result = memmove(a2, "Parametro de resultado da transacao nao pode ser nulo", 0x35uLL);
          break;
        case 11:
          result = memmove(a2, "Parametro de codigo de venda nao pode ser nulo", 0x2EuLL);
          break;
        case 12:
          result = memmove(a2, "Parametro de valor total da transacao nao pode ser nulo", 0x37uLL);
          break;
        case 13:
          result = memmove(a2, "Parametro de valor da transacao nao pode ser nulo", 0x31uLL);
          break;
        case 14:
          result = memmove(a2, "Buffer de resposta invalido, refaca a transacao", 0x2FuLL);
          break;
        case 15:
          result = memmove(a2, "Transacao negada", 0x10uLL);
          break;
        case 16:
          result = memmove(a2, "Terminal nao esta pronto para transacionar", 0x2AuLL);
          break;
        case 17:
          v5 = "Parametro de aplicacao invalido";
          return memmove(a2, v5, 0x1FuLL);
        case 18:
          result = memmove(a2, "Erro ao gerar mensagem de transacao", 0x23uLL);
          break;
        default:
          return result;
      }
    }
    else
    {
      v5 = "Transacao realizada com sucesso";
      return memmove(a2, v5, 0x1FuLL);
    }
  }
  return result;
}

//----- (0000000180003160) ----------------------------------------------------
__int64 __fastcall sub_180003160(char *a1)
{
  char v1; // al
  char *v2; // rbx

  v1 = *a1;
  v2 = a1;
  if ( !*a1 )
    return 1LL;
  while ( 1 )
  {
    ++v2;
    if ( !isdigit(v1) )
      break;
    v1 = *v2;
    if ( !*v2 )
      return 1LL;
  }
  return 0LL;
}

//----- (00000001800031A0) ----------------------------------------------------
__int64 __fastcall sub_1800031A0(__int64 a1, __int64 a2, __int64 a3, _BYTE *a4, char *a5, __int64 a6, __int64 a7)
{
  __int64 result; // rax
  _BYTE *v9; // rbx
  unsigned __int64 v11; // rbx
  __int64 v12; // rax
  __int64 v13; // rax

  if ( !a4 )
    return 4294966290LL;
  v9 = a4;
  if ( *a4 )
  {
    while ( isdigit((char)*v9++) )
    {
      if ( !*v9 )
        goto LABEL_6;
    }
    return 4294966284LL;
  }
LABEL_6:
  v11 = -1LL;
  v12 = -1LL;
  do
    ++v12;
  while ( a4[v12] );
  if ( !v12 )
    return 4294966290LL;
  if ( !a5 )
    return 4294966289LL;
  if ( !(unsigned int)sub_180003160(a5) )
    return 4294966284LL;
  v13 = -1LL;
  do
    ++v13;
  while ( a5[v13] );
  if ( !v13 )
    return 4294966289LL;
  if ( !a6 )
    return 4294966288LL;
  do
    ++v11;
  while ( *(_BYTE *)(a6 + v11) );
  if ( v11 > 0xB )
    return 4294966283LL;
  result = 0LL;
  if ( !a7 )
    return 4294966287LL;
  return result;
}

//----- (00000001800032B0) ----------------------------------------------------
int __fastcall sub_1800032B0(__int64 a1)
{
  unsigned __int16 i; // bp
  __int64 v3; // rax
  unsigned __int16 v4; // dx
  __int64 v5; // rsi
  _WORD *v6; // rcx
  const char *v7; // rax
  int v8; // ebx
  unsigned __int16 j; // di
  int v10; // ebx
  unsigned __int16 k; // di
  unsigned __int8 v12; // dl
  int v13; // eax
  char Buffer[1024]; // [rsp+30h] [rbp-438h] BYREF

  memset(Buffer, 0, sizeof(Buffer));
  sub_180001230(0, "%s\n", "***************************************************************");
  sub_180001230(0, "DUMPING MSG [%04X] NTAGS: %d\n", *(unsigned __int16 *)(a1 + 2), *(unsigned __int8 *)(a1 + 604));
  sub_180001230(0, "%s\n", "***************************************************************");
  for ( i = 0; i < *(unsigned __int8 *)(a1 + 604); ++i )
  {
    v3 = 0LL;
    v4 = *(_WORD *)(a1 + 12LL * i + 4);
    v5 = a1 + 12LL * i;
    v6 = &unk_180008070;
    while ( *v6 != v4 )
    {
      v3 = (unsigned int)(v3 + 1);
      v6 += 5;
      if ( (unsigned int)v3 >= 0x12 )
      {
        v7 = "TAG UNKNOW";
        goto LABEL_7;
      }
    }
    v7 = *(const char **)((char *)&unk_180008070 + 10 * v3 + 2);
LABEL_7:
    v8 = sub_180002F40(Buffer, 0x3FFuLL, "[%04X][%s]: ", v4, v7);
    for ( j = 0; j < *(_WORD *)(v5 + 6); ++j )
      v8 += sub_180002F40(&Buffer[v8], 0x3FFuLL, "%02X ", *(unsigned __int8 *)(j + *(_QWORD *)(v5 + 8)));
    v10 = sub_180002F40(&Buffer[v8], 0x3FFuLL, "(") + v8;
    for ( k = 0; k < *(_WORD *)(v5 + 6); ++k )
    {
      v12 = *(_BYTE *)(k + *(_QWORD *)(v5 + 8));
      if ( (unsigned __int8)(v12 - 32) > 0x5Eu )
        v13 = sub_180002F40(&Buffer[v10], 0x3FFuLL, ".");
      else
        v13 = sub_180002F40(&Buffer[v10], 0x3FFuLL, "%c", v12);
      v10 += v13;
    }
    sub_180002F40(&Buffer[v10], 0x3FFuLL, ")");
    sub_180001230(0, "%s\n", Buffer);
  }
  return sub_180001230(0, "%s\n", "***************************************************************");
}
// 1800032B0: using guessed type char Buffer[1024];

//----- (0000000180003530) ----------------------------------------------------
__int64 __fastcall sub_180003530(__int64 a1, _BYTE *a2, _DWORD *a3)
{
  int v3; // ebx
  unsigned __int8 v7; // al
  unsigned __int16 *v8; // rcx
  __int64 v9; // rdx
  int v10; // eax
  unsigned __int8 v12; // r14
  _BYTE *v13; // rsi
  __int64 v14; // rbx
  unsigned int v15; // ebp
  int v16; // [rsp+20h] [rbp-58h]
  char v17; // [rsp+24h] [rbp-54h] BYREF
  char v18; // [rsp+25h] [rbp-53h]
  __int16 Src; // [rsp+28h] [rbp-50h] BYREF

  v3 = 0;
  if ( !a1 || !a2 || !a3 )
    return 4294966294LL;
  v7 = *(_BYTE *)(a1 + 604);
  if ( v7 )
  {
    v8 = (unsigned __int16 *)(a1 + 6);
    v9 = v7;
    do
    {
      v10 = *v8;
      v8 += 6;
      v3 += v10 + 4;
      --v9;
    }
    while ( v9 );
  }
  v16 = v3 + 6;
  if ( *a3 < (unsigned int)(v3 + 6) )
    return 4294966295LL;
  Src = *(_WORD *)a1;
  memmove(&v17, &Src, 2uLL);
  *a2 = v18;
  a2[1] = v17;
  Src = *(_WORD *)(a1 + 2);
  memmove(&v17, &Src, 2uLL);
  a2[2] = v18;
  a2[3] = v17;
  Src = v3;
  memmove(&v17, &Src, 2uLL);
  v12 = 0;
  a2[4] = v18;
  a2[5] = v17;
  v13 = a2 + 6;
  if ( *(_BYTE *)(a1 + 604) )
  {
    while ( 1 )
    {
      v14 = a1 + 4 * (v12 + 2LL * v12 + 1);
      if ( !v14 )
        return 4294965297LL;
      if ( !v13 )
        return 4294965297LL;
      v15 = *(unsigned __int16 *)(v14 + 2) + 4;
      if ( (int)a2 + *a3 - (int)v13 < v15 )
        return 4294965297LL;
      sub_1800040F0(v13, *(_WORD *)v14);
      sub_1800040F0(v13 + 2, *(_WORD *)(v14 + 2));
      memmove(v13 + 4, *(const void **)(v14 + 4), *(unsigned __int16 *)(v14 + 2));
      ++v12;
      v13 += v15;
      if ( v12 >= *(_BYTE *)(a1 + 604) )
        goto LABEL_14;
    }
  }
  else
  {
LABEL_14:
    *a3 = v16;
    return 0LL;
  }
}

//----- (0000000180003730) ----------------------------------------------------
__int64 __fastcall sub_180003730(__int64 a1, unsigned __int8 *a2)
{
  __int16 v4; // ax
  __int16 v5; // bp
  unsigned __int8 *v6; // rsi
  unsigned __int16 v7; // bp
  unsigned int v8; // r15d
  __int64 v9; // r14
  unsigned __int16 v10; // dx
  void *v11; // rax
  size_t v12; // r8
  int v13; // edi
  __int64 v15; // [rsp+28h] [rbp-50h]
  unsigned int v16; // [rsp+30h] [rbp-48h] BYREF

  if ( !a1 || !a2 )
    return 4294966294LL;
  sub_180001230(1, "TRACE|%s:%d|\n", "MessageParseBuffer", 275LL);
  *(_WORD *)a1 = a2[1] + (*a2 << 8);
  *(_WORD *)(a1 + 2) = a2[3] + (a2[2] << 8);
  v4 = a2[5];
  v5 = a2[4];
  v6 = a2 + 6;
  v7 = v4 + (v5 << 8);
  sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "MessageParseBuffer", 282LL, "data_length", v7);
  *(_BYTE *)(a1 + 604) = 0;
  if ( v7 )
  {
    v8 = v16;
    while ( 1 )
    {
      v9 = a1 + 4 * (*(unsigned __int8 *)(a1 + 604) + 2LL * *(unsigned __int8 *)(a1 + 604) + 1);
      if ( v9 && v6 )
      {
        memmove(&v16, v6, 2uLL);
        *(_WORD *)v9 = BYTE1(v16) + ((unsigned __int8)v16 << 8);
        memmove(&v16, v6 + 2, 2uLL);
        v10 = BYTE1(v16) + ((unsigned __int8)v16 << 8);
        *(_WORD *)(v9 + 2) = v10;
        v11 = malloc(v10);
        v12 = *(unsigned __int16 *)(v9 + 2);
        *(_QWORD *)(v9 + 4) = v11;
        memmove(v11, v6 + 4, v12);
        v8 = *(unsigned __int16 *)(v9 + 2) + 4;
        v13 = 0;
      }
      else
      {
        v13 = 2;
      }
      LODWORD(v15) = v13;
      sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "MessageParseBuffer", 290LL, "ret_code", v15);
      if ( v13 )
        return 4294965297LL;
      ++*(_BYTE *)(a1 + 604);
      v7 -= v8;
      v6 += v8;
      if ( *(_BYTE *)(a1 + 604) >= 0x32u )
        return 4294966282LL;
      if ( !v7 )
        goto LABEL_12;
    }
  }
  else
  {
LABEL_12:
    sub_180001230(1, "TRACE|%s:%d|\n", "MessageParseBuffer", 306LL);
    return 0LL;
  }
}
// 180003905: variable 'v15' is possibly undefined

//----- (00000001800039A0) ----------------------------------------------------
__int64 __fastcall sub_1800039A0(_BYTE *a1)
{
  unsigned __int8 v1; // di
  char *v3; // rbx

  v1 = 0;
  if ( a1[604] )
  {
    while ( 1 )
    {
      v3 = &a1[8 * v1 + 4 + 4 * v1];
      if ( !v3 )
        return 4294965297LL;
      free(*(void **)(v3 + 4));
      ++v1;
      *(_QWORD *)v3 = 0LL;
      *((_DWORD *)v3 + 2) = 0;
      if ( v1 >= a1[604] )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    memset(a1, 0, 0x25DuLL);
    return 0LL;
  }
}

//----- (0000000180003A30) ----------------------------------------------------
__int64 __fastcall sub_180003A30(__int64 a1, unsigned int *a2)
{
  int v4; // ebx
  unsigned int v6; // ebx
  int v7; // ebp
  int v8; // [rsp+28h] [rbp-10h]
  __int64 v9; // [rsp+28h] [rbp-10h]
  __int64 v10; // [rsp+28h] [rbp-10h]
  __int64 v11; // [rsp+28h] [rbp-10h]

  v8 = SerialPortRead[0]();
  v4 = v8;
  sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "MessageReceive", 382LL, "ret_read", v8);
  if ( v4 < 0 )
    return (unsigned int)v4;
  v6 = (unsigned __int16)(*(unsigned __int8 *)(a1 + 5) + 6 + (*(unsigned __int8 *)(a1 + 4) << 8));
  if ( v6 > *a2 - 16 )
    return 4294966282LL;
  LODWORD(v9) = (unsigned __int16)(*(unsigned __int8 *)(a1 + 5) + 6 + (*(unsigned __int8 *)(a1 + 4) << 8));
  sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "MessageReceive", 393LL, "expected_bytes", v9);
  LODWORD(v10) = v6 - 16;
  sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "MessageReceive", 394LL, "expected_bytes - HEADER_SIZE", v10);
  LODWORD(v11) = SerialPortRead[0]();
  v7 = v11;
  sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "MessageReceive", 396LL, "ret_read", v11);
  sub_180001330("msg_buffer", (char *)a1, v6);
  if ( v7 < 0 )
    return (unsigned int)v7;
  *a2 = v6;
  return 0LL;
}
// 180008055: invalid function type '?' has been ignored
// 180008055: invalid function type '__int64 (__fastcall *SerialPortRead[3])()' has been ignored
// 180003AF2: variable 'v9' is possibly undefined
// 180003B23: variable 'v10' is possibly undefined
// 180003B5F: variable 'v11' is possibly undefined
// 180008055: using guessed type __int64 (__fastcall *SerialPortRead[3])();

//----- (0000000180003BA0) ----------------------------------------------------
__int64 __fastcall sub_180003BA0(__int64 a1, __int64 a2)
{
  unsigned __int8 v5; // r8
  unsigned __int8 v6; // dl
  __int64 v7; // rax
  bool v8; // zf
  const void *v9; // rax
  size_t v10; // r8
  unsigned __int8 v11; // r8
  unsigned __int8 v12; // dl
  char *v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r8
  char v16; // al
  unsigned __int8 v17; // r8
  unsigned __int8 v18; // dl
  size_t v19; // rsi
  __int64 v20; // rax
  const void *v21; // rax
  size_t v22; // r8
  unsigned __int8 v23; // r8
  unsigned __int8 v24; // dl
  __int64 v25; // rax
  const void *v26; // rax
  size_t v27; // r8
  unsigned __int8 v28; // r8
  unsigned __int8 v29; // dl
  __int64 v30; // rax
  const void *v31; // rax
  size_t v32; // r8
  unsigned __int8 v33; // r8
  unsigned __int8 v34; // dl
  __int64 v35; // rax
  const void *v36; // rax
  size_t v37; // r8
  unsigned __int8 v38; // r8
  unsigned __int8 v39; // dl
  __int64 v40; // rax
  const void *v41; // rax
  size_t v42; // r8
  unsigned __int8 v43; // r8
  unsigned __int8 v44; // dl
  __int64 v45; // rax
  const void *v46; // rax
  size_t v47; // r8
  unsigned __int8 v48; // r8
  unsigned __int8 v49; // dl
  __int64 v50; // rax
  const void *v51; // rax
  void *Src[2]; // [rsp+20h] [rbp-20h] BYREF

  if ( !a1 )
    return 4294966291LL;
  if ( !a2 )
    return 4294966287LL;
  v5 = *(_BYTE *)(a1 + 604);
  v6 = 0;
  memset(Src, 0, 12);
  if ( v5 )
  {
    while ( 1 )
    {
      v7 = 3LL * v6 + 1;
      v8 = *(_WORD *)(a1 + 4 * v7) == 5;
      v9 = (const void *)(a1 + 4 * v7);
      if ( v8 )
        break;
      if ( ++v6 >= v5 )
        goto LABEL_12;
    }
    memmove(Src, v9, 0xCuLL);
    v10 = WORD1(Src[0]);
    if ( WORD1(Src[0]) > 0x40u )
      v10 = 64LL;
    memmove((void *)(a2 + 66687), *(const void **)((char *)Src + 4), v10);
  }
LABEL_12:
  v11 = *(_BYTE *)(a1 + 604);
  v12 = 0;
  memset(Src, 0, 12);
  if ( v11 )
  {
    while ( *(_WORD *)(a1 + 12LL * v12 + 4) != 40 )
    {
      if ( ++v12 >= v11 )
        goto LABEL_21;
    }
    memmove(Src, (const void *)(a1 + 12LL * v12 + 4), 0xCuLL);
    v13 = *(char **)((char *)Src + 4);
    v14 = a2 + 66567;
    if ( *(void **)((char *)Src + 4) && a2 != -66567 && WORD1(Src[0]) )
    {
      v15 = WORD1(Src[0]);
      do
      {
        v14 += 2LL;
        *(_BYTE *)(v14 - 2) = a0123456789abcd_0[(unsigned __int64)(unsigned __int8)*v13 >> 4];
        v16 = *v13++;
        *(_BYTE *)(v14 - 1) = a0123456789abcd_0[v16 & 0xF];
        --v15;
      }
      while ( v15 );
    }
  }
LABEL_21:
  v17 = *(_BYTE *)(a1 + 604);
  v18 = 0;
  memset(Src, 0, 12);
  v19 = 10LL;
  if ( v17 )
  {
    while ( 1 )
    {
      v20 = 3LL * v18 + 1;
      v8 = *(_WORD *)(a1 + 4 * v20) == 41;
      v21 = (const void *)(a1 + 4 * v20);
      if ( v8 )
        break;
      if ( ++v18 >= v17 )
        goto LABEL_28;
    }
    memmove(Src, v21, 0xCuLL);
    v22 = WORD1(Src[0]);
    if ( WORD1(Src[0]) > 0xAu )
      v22 = 10LL;
    memmove((void *)(a2 + 66600), *(const void **)((char *)Src + 4), v22);
  }
LABEL_28:
  v23 = *(_BYTE *)(a1 + 604);
  v24 = 0;
  memset(Src, 0, 12);
  if ( v23 )
  {
    while ( 1 )
    {
      v25 = 3LL * v24 + 1;
      v8 = *(_WORD *)(a1 + 4 * v25) == 70;
      v26 = (const void *)(a1 + 4 * v25);
      if ( v8 )
        break;
      if ( ++v24 >= v23 )
        goto LABEL_35;
    }
    memmove(Src, v26, 0xCuLL);
    v27 = WORD1(Src[0]);
    if ( WORD1(Src[0]) > 8u )
      v27 = 8LL;
    memmove((void *)(a2 + 66611), *(const void **)((char *)Src + 4), v27);
  }
LABEL_35:
  v28 = *(_BYTE *)(a1 + 604);
  v29 = 0;
  memset(Src, 0, 12);
  if ( v28 )
  {
    while ( 1 )
    {
      v30 = 3LL * v29 + 1;
      v8 = *(_WORD *)(a1 + 4 * v30) == 48;
      v31 = (const void *)(a1 + 4 * v30);
      if ( v8 )
        break;
      if ( ++v29 >= v28 )
        goto LABEL_42;
    }
    memmove(Src, v31, 0xCuLL);
    v32 = WORD1(Src[0]);
    if ( WORD1(Src[0]) > 0xCu )
      v32 = 12LL;
    memmove((void *)(a2 + 66620), *(const void **)((char *)Src + 4), v32);
  }
LABEL_42:
  v33 = *(_BYTE *)(a1 + 604);
  v34 = 0;
  memset(Src, 0, 12);
  if ( v33 )
  {
    while ( 1 )
    {
      v35 = 3LL * v34 + 1;
      v8 = *(_WORD *)(a1 + 4 * v35) == 50;
      v36 = (const void *)(a1 + 4 * v35);
      if ( v8 )
        break;
      if ( ++v34 >= v33 )
        goto LABEL_49;
    }
    memmove(Src, v36, 0xCuLL);
    v37 = WORD1(Src[0]);
    if ( WORD1(Src[0]) > 0x1Eu )
      v37 = 30LL;
    memmove((void *)(a2 + 66633), *(const void **)((char *)Src + 4), v37);
  }
LABEL_49:
  v38 = *(_BYTE *)(a1 + 604);
  v39 = 0;
  memset(Src, 0, 12);
  if ( v38 )
  {
    while ( 1 )
    {
      v40 = 3LL * v39 + 1;
      v8 = *(_WORD *)(a1 + 4 * v40) == 51;
      v41 = (const void *)(a1 + 4 * v40);
      if ( v8 )
        break;
      if ( ++v39 >= v38 )
        goto LABEL_56;
    }
    memmove(Src, v41, 0xCuLL);
    v42 = WORD1(Src[0]);
    if ( WORD1(Src[0]) > 6u )
      v42 = 6LL;
    memmove((void *)(a2 + 66664), *(const void **)((char *)Src + 4), v42);
  }
LABEL_56:
  v43 = *(_BYTE *)(a1 + 604);
  v44 = 0;
  memset(Src, 0, 12);
  if ( v43 )
  {
    while ( 1 )
    {
      v45 = 3LL * v44 + 1;
      v8 = *(_WORD *)(a1 + 4 * v45) == 52;
      v46 = (const void *)(a1 + 4 * v45);
      if ( v8 )
        break;
      if ( ++v44 >= v43 )
        goto LABEL_63;
    }
    memmove(Src, v46, 0xCuLL);
    v47 = WORD1(Src[0]);
    if ( WORD1(Src[0]) > 4u )
      v47 = 4LL;
    memmove((void *)(a2 + 66671), *(const void **)((char *)Src + 4), v47);
  }
LABEL_63:
  v48 = *(_BYTE *)(a1 + 604);
  v49 = 0;
  memset(Src, 0, 12);
  if ( v48 )
  {
    while ( 1 )
    {
      v50 = 3LL * v49 + 1;
      v8 = *(_WORD *)(a1 + 4 * v50) == 71;
      v51 = (const void *)(a1 + 4 * v50);
      if ( v8 )
        break;
      if ( ++v49 >= v48 )
        return 0LL;
    }
    memmove(Src, v51, 0xCuLL);
    if ( WORD1(Src[0]) <= 0xAu )
      v19 = WORD1(Src[0]);
    memmove((void *)(a2 + 66676), *(const void **)((char *)Src + 4), v19);
  }
  return 0LL;
}

//----- (0000000180004030) ----------------------------------------------------
void *__fastcall sub_180004030(void *Src, char *a2)
{
  char *v2; // rbx
  int v4; // edi
  size_t v5; // rsi
  void *result; // rax
  char v7[48]; // [rsp+20h] [rbp-58h] BYREF
  __int16 v8; // [rsp+50h] [rbp-28h]

  v2 = v7;
  memset(v7, 0, sizeof(v7));
  v4 = 12;
  v8 = 0;
  memmove(v7, Src, 0xCuLL);
  if ( v7[0] == 48 )
  {
    do
    {
      ++v2;
      --v4;
    }
    while ( *v2 == 48 );
  }
  v5 = v4 - 2;
  memmove(a2, v2, v5);
  a2[v5] = 46;
  result = memmove(&a2[v5 + 1], &v2[v5], 2uLL);
  a2[v5 + 3] = 0;
  return result;
}

//----- (00000001800040F0) ----------------------------------------------------
__int64 __fastcall sub_1800040F0(_BYTE *a1, __int16 a2)
{
  __int64 result; // rax
  char v4[8]; // [rsp+20h] [rbp-28h] BYREF
  __int16 Src; // [rsp+28h] [rbp-20h] BYREF

  Src = a2;
  memmove(v4, &Src, 2uLL);
  *a1 = v4[1];
  result = (unsigned __int8)v4[0];
  a1[1] = v4[0];
  return result;
}

//----- (0000000180004714) ----------------------------------------------------
char sub_180004714()
{
  if ( !sub_180004FA4() )
    return 0;
  if ( !sub_180004FA4() )
  {
    sub_180004FA4();
    return 0;
  }
  return 1;
}

//----- (0000000180004B38) ----------------------------------------------------
void sub_180004B38()
{
  InitializeSListHead(&stru_1800086F0);
}
// 1800086F0: using guessed type union _SLIST_HEADER stru_1800086F0;

//----- (0000000180004B48) ----------------------------------------------------
void __fastcall sub_180004B48()
{
  _std_type_info_destroy_list(&stru_1800086F0);
}
// 180004F56: using guessed type __int64 __fastcall _std_type_info_destroy_list(_QWORD);
// 1800086F0: using guessed type union _SLIST_HEADER stru_1800086F0;

//----- (0000000180004B54) ----------------------------------------------------
void *sub_180004B54()
{
  return &unk_180008700;
}

//----- (0000000180004B78) ----------------------------------------------------
void *sub_180004B78()
{
  return &unk_180008880;
}

//----- (0000000180004CC8) ----------------------------------------------------
__int64 sub_180004CC8()
{
  _QWORD *i; // rbx
  __int64 result; // rax

  for ( i = qword_180006E28; i < qword_180006E28; ++i )
  {
    if ( *i )
      result = ((__int64 (__fastcall *)(_QWORD))*i)(*i);
  }
  return result;
}
// 180004D60: using guessed type __int64 __fastcall j__guard_check_icall_nop();
// 180006E28: using guessed type _QWORD qword_180006E28[2];

//----- (0000000180004D14) ----------------------------------------------------
void __fastcall sub_180004D14()
{
  _QWORD *i; // rbx

  for ( i = &qword_180006E38; i < &qword_180006E38; ++i )
  {
    if ( *i )
      ((void (__fastcall *)(_QWORD))*i)(*i);
  }
}
// 180004D60: using guessed type __int64 __fastcall j__guard_check_icall_nop();
// 180006E38: using guessed type _QWORD qword_180006E38;

//----- (0000000180004FA4) ----------------------------------------------------
char sub_180004FA4()
{
  return 1;
}

//----- (0000000180004FA8) ----------------------------------------------------
__int64 sub_180004FA8()
{
  return 0LL;
}

// nfuncs=92 queued=39 decompiled=39 lumina nreq=0 worse=0 better=0
// ALL OK, 39 function(s) have been successfully decompiled
