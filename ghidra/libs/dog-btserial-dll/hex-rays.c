/* This file was generated by the Hex-Rays decompiler version 8.4.0.240320.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

void *sub_180001000();
int sub_180001010(FILE *Stream, char *Format, ...);
int sub_180001060(char *Format, ...);
const char *sub_1800010C0();
char *sub_180001170();
int sub_180001230(int a1, const char *a2, ...);
int sub_180001330(char *Buffer, size_t BufferCount, char *Format, ...);
HANDLE __fastcall sub_180001390(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite);
__int64 __fastcall SerialPortOpen(char *Source); // idb
__int64 __fastcall SerialPortRead(LPVOID lpBuffer, DWORD nNumberOfBytesToRead, unsigned int a3);
__int64 __fastcall SerialPortWrite(__int64 a1, unsigned int a2);
BOOL SerialPortClose();
char sub_180001F74();
void sub_180002398();
void __fastcall sub_1800023A8();
void *sub_1800023B4();
void *sub_1800023D8();
__int64 sub_180002528();
void __fastcall sub_180002574();
__int64 __fastcall j__guard_check_icall_nop(); // weak
// __int64 __fastcall _std_type_info_destroy_list(_QWORD); weak
// void *__cdecl memset(void *, int Val, size_t Size);
char sub_180002804();
__int64 sub_180002808();

//-------------------------------------------------------------------------
// Data declarations

// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetLastError)();
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern BOOL (__stdcall *GetCommState)(HANDLE hFile, LPDCB lpDCB);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *ClearCommError)(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat);
// extern BOOL (__stdcall *GetOverlappedResult)(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern BOOL (__stdcall *SetCommTimeouts)(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);
// extern BOOL (__stdcall *SetCommState)(HANDLE hFile, LPDCB lpDCB);
// extern BOOL (__stdcall *FlushFileBuffers)(HANDLE hFile);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern char *(__cdecl *strstr)(const char *Str, const char *SubStr);
// extern int (__cdecl *_stdio_common_vfprintf)(unsigned __int64 Options, FILE *Stream, const char *Format, _locale_t Locale, va_list ArgList);
// extern int (__cdecl *fclose)(FILE *Stream);
// extern int (__cdecl *fflush)(FILE *Stream);
// extern int (__cdecl *_stdio_common_vsprintf_s)(unsigned __int64 Options, char *Buffer, size_t BufferCount, const char *Format, _locale_t Locale, va_list ArgList);
// extern FILE *(__cdecl *_acrt_iob_func)(unsigned int Ix);
// extern errno_t (__cdecl *fopen_s)(FILE **Stream, const char *FileName, const char *Mode);
// extern errno_t (__cdecl *strncpy_s)(char *Destination, rsize_t SizeInBytes, const char *Source, rsize_t MaxCount);
// extern size_t (__cdecl *strftime)(char *Buffer, size_t SizeInBytes, const char *Format, const struct tm *Tm);
// extern errno_t (__cdecl *localtime64_s)(struct tm *Tm, const __time64_t *Time);
// extern __time64_t (__cdecl *time64)(__time64_t *Time);
_QWORD qword_1800037A0[2] = { 0LL, 0LL }; // weak
_QWORD qword_1800037B0 = 0LL; // weak
union _SLIST_HEADER stru_180005600; // weak
_UNKNOWN unk_180005610; // weak
char Buffer; // idb
char qword_180005720[]; // idb
__int64 qword_180005728; // weak
__int64 qword_180005730; // weak
__int64 qword_180005738; // weak
__int64 qword_180005740; // weak
__int64 qword_180005748; // weak
__int64 qword_180005750; // weak
__int64 qword_180005758; // weak
HANDLE hObject; // idb
struct _DCB DCB; // idb
struct _COMMTIMEOUTS CommTimeouts; // idb
_UNKNOWN unk_1800057A0; // weak
_UNKNOWN unk_1800057A8; // weak


//----- (0000000180001000) ----------------------------------------------------
void *sub_180001000()
{
  return &unk_1800057A8;
}

//----- (0000000180001010) ----------------------------------------------------
int sub_180001010(FILE *Stream, char *Format, ...)
{
  unsigned __int64 *v4; // rax
  va_list va; // [rsp+60h] [rbp+18h] BYREF

  va_start(va, Format);
  v4 = (unsigned __int64 *)sub_180001000();
  return _stdio_common_vfprintf(*v4, Stream, Format, 0LL, va);
}

//----- (0000000180001060) ----------------------------------------------------
int sub_180001060(char *Format, ...)
{
  FILE *v2; // rbx
  unsigned __int64 *v3; // rax
  va_list va; // [rsp+58h] [rbp+10h] BYREF

  va_start(va, Format);
  v2 = _acrt_iob_func(1u);
  v3 = (unsigned __int64 *)sub_180001000();
  return _stdio_common_vfprintf(*v3, v2, Format, 0LL, va);
}

//----- (00000001800010C0) ----------------------------------------------------
const char *sub_1800010C0()
{
  __time64_t Time; // [rsp+20h] [rbp-48h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-40h] BYREF

  if ( Buffer )
    return &Buffer;
  Time = time64(0LL);
  localtime64_s(&Tm, &Time);
  if ( strftime(&Buffer, 0x100uLL, "PPPAGSEGURO_%Y-%m-%d.log", &Tm) )
    return &Buffer;
  memset(&Buffer, 0, 0x100uLL);
  return "PPPAGSEGURO.log";
}

//----- (0000000180001170) ----------------------------------------------------
char *sub_180001170()
{
  __time64_t Time; // [rsp+20h] [rbp-48h] BYREF
  struct tm Tm; // [rsp+28h] [rbp-40h] BYREF

  Time = time64(0LL);
  localtime64_s(&Tm, &Time);
  if ( strftime(qword_180005720, 0x40uLL, "%H:%M:%S|", &Tm) )
    return qword_180005720;
  *(_QWORD *)qword_180005720 = 0LL;
  qword_180005728 = 0LL;
  qword_180005730 = 0LL;
  qword_180005738 = 0LL;
  qword_180005740 = 0LL;
  qword_180005748 = 0LL;
  qword_180005750 = 0LL;
  qword_180005758 = 0LL;
  return "00:00:00|";
}
// 180005728: using guessed type __int64 qword_180005728;
// 180005730: using guessed type __int64 qword_180005730;
// 180005738: using guessed type __int64 qword_180005738;
// 180005740: using guessed type __int64 qword_180005740;
// 180005748: using guessed type __int64 qword_180005748;
// 180005750: using guessed type __int64 qword_180005750;
// 180005758: using guessed type __int64 qword_180005758;

//----- (0000000180001230) ----------------------------------------------------
int sub_180001230(int a1, const char *a2, ...)
{
  char *v3; // rsi
  const char *v4; // rax
  FILE *v5; // rdi
  unsigned __int64 *v6; // rax
  FILE *v7; // rbx
  unsigned __int64 *v8; // rax
  FILE *Stream; // [rsp+30h] [rbp-38h] BYREF
  va_list va; // [rsp+80h] [rbp+18h] BYREF

  va_start(va, a2);
  v3 = sub_180001170();
  v4 = sub_1800010C0();
  fopen_s(&Stream, v4, "a+");
  v5 = Stream;
  if ( Stream )
  {
    if ( a1 )
    {
      sub_180001010(Stream, "%s", v3);
      v5 = Stream;
    }
    v6 = (unsigned __int64 *)sub_180001000();
    _stdio_common_vfprintf(*v6, v5, a2, 0LL, va);
    fflush(Stream);
    fclose(Stream);
  }
  if ( a1 )
    sub_180001060("%s", v3);
  v7 = _acrt_iob_func(1u);
  v8 = (unsigned __int64 *)sub_180001000();
  return _stdio_common_vfprintf(*v8, v7, a2, 0LL, va);
}

//----- (0000000180001330) ----------------------------------------------------
int sub_180001330(char *Buffer, size_t BufferCount, char *Format, ...)
{
  unsigned __int64 *v6; // rax
  int result; // eax
  va_list va; // [rsp+78h] [rbp+20h] BYREF

  va_start(va, Format);
  v6 = (unsigned __int64 *)sub_180001000();
  result = _stdio_common_vsprintf_s(*v6, Buffer, BufferCount, Format, 0LL, va);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (0000000180001390) ----------------------------------------------------
HANDLE __fastcall sub_180001390(LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite)
{
  unsigned int v2; // ebx
  HANDLE result; // rax
  struct _OVERLAPPED Overlapped; // [rsp+30h] [rbp-38h] BYREF
  DWORD NumberOfBytesWritten; // [rsp+50h] [rbp-18h] BYREF

  v2 = 0;
  memset(&Overlapped, 0, 24);
  result = CreateEventA(0LL, 1, 0, 0LL);
  Overlapped.hEvent = result;
  if ( result )
  {
    if ( !WriteFile(hObject, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, &Overlapped) )
    {
      if ( GetLastError() != 997 || WaitForSingleObject(Overlapped.hEvent, 0xFFFFFFFF) )
        goto LABEL_8;
      if ( GetOverlappedResult(hObject, &Overlapped, &NumberOfBytesWritten, 0) )
        FlushFileBuffers(hObject);
    }
    v2 = 1;
LABEL_8:
    CloseHandle(Overlapped.hEvent);
    return (HANDLE)v2;
  }
  return result;
}

//----- (0000000180001490) ----------------------------------------------------
__int64 __fastcall SerialPortOpen(char *Source)
{
  __int64 result; // rax
  unsigned int v3; // ebx
  __int64 dwFlagsAndAttributes; // [rsp+28h] [rbp-40h]
  char Destination[8]; // [rsp+40h] [rbp-28h] BYREF
  __int64 v6; // [rsp+48h] [rbp-20h]
  int v7; // [rsp+50h] [rbp-18h]

  *(_QWORD *)Destination = 0LL;
  v6 = 0LL;
  v7 = 0;
  sub_180001230(1, "DVARS|%s:%d|[%s]: %s\n", "SerialPortOpen");
  if ( strstr(Source, "COM") == Source )
    sub_180001330(Destination, 0x14uLL, "\\\\.\\%s", Source);
  else
    strncpy_s(Destination, 0x14uLL, Source, 0x13uLL);
  hObject = CreateFileA(Destination, 0xC0000000, 0, 0LL, 3u, 0x40000080u, 0LL);
  sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "SerialPortOpen", 109LL, "g_hdlSerialPort", hObject);
  if ( hObject == (HANDLE)-1LL )
  {
    LODWORD(dwFlagsAndAttributes) = GetLastError();
    sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "SerialPortOpen", 112LL, "GetLastError()", dwFlagsAndAttributes);
    return 4294965295LL;
  }
  sub_180001230(1, "TRACE|%s:%d|%s\n", "SerialPortOpen", 116LL, "configurando porta com");
  DCB.DCBlength = 28;
  if ( !GetCommState(hObject, &DCB) )
  {
    LODWORD(dwFlagsAndAttributes) = GetLastError();
    sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "SerialPortOpen", 120LL, "GetLastError()", dwFlagsAndAttributes);
    v3 = -2002;
LABEL_11:
    CloseHandle(hObject);
    result = v3;
    hObject = 0LL;
    return result;
  }
  DCB.BaudRate = 115200;
  *(_WORD *)&DCB.ByteSize = 8;
  DCB.StopBits = 0;
  if ( !SetCommState(hObject, &DCB)
    || (sub_180001230(1, "TRACE|%s:%d|%s\n", "SerialPortOpen", 134LL, "OK."),
        CommTimeouts.ReadIntervalTimeout = 50,
        CommTimeouts.ReadTotalTimeoutConstant = 50,
        CommTimeouts.ReadTotalTimeoutMultiplier = 10,
        CommTimeouts.WriteTotalTimeoutConstant = 50,
        CommTimeouts.WriteTotalTimeoutMultiplier = 10,
        !SetCommTimeouts(hObject, &CommTimeouts)) )
  {
    v3 = -2003;
    goto LABEL_11;
  }
  sub_180001230(1, "TRACE|%s:%d|success opening '%s'\n", "SerialPortOpen", 148LL, Source);
  return 0LL;
}
// 1800015CF: variable 'dwFlagsAndAttributes' is possibly undefined

//----- (0000000180001790) ----------------------------------------------------
__int64 __fastcall SerialPortRead(LPVOID lpBuffer, DWORD nNumberOfBytesToRead, unsigned int a3)
{
  DWORD cbInQue; // edi
  unsigned int v6; // ebx
  struct _OVERLAPPED Overlapped; // [rsp+30h] [rbp-68h] BYREF
  DWORD Errors; // [rsp+50h] [rbp-48h] BYREF
  struct _COMSTAT Stat; // [rsp+58h] [rbp-40h] BYREF
  DWORD NumberOfBytesRead; // [rsp+68h] [rbp-30h] BYREF

  cbInQue = 0;
  v6 = a3 / 0xFA;
  if ( a3 / 0xFA )
  {
    while ( 1 )
    {
      --v6;
      if ( hObject == (HANDLE)-1LL )
      {
        cbInQue = 0;
      }
      else
      {
        Errors = 0;
        *(_QWORD *)&Stat = 0LL;
        Stat.cbOutQue = 0;
        ClearCommError(hObject, &Errors, &Stat);
        cbInQue = Stat.cbInQue;
      }
      if ( cbInQue >= nNumberOfBytesToRead )
        break;
      Sleep(0xFAu);
      if ( !v6 )
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    if ( cbInQue < nNumberOfBytesToRead )
      return 4294965292LL;
  }
  memset(&Overlapped, 0, 24);
  Overlapped.hEvent = CreateEventA(0LL, 1, 0, 0LL);
  ReadFile(hObject, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead, &Overlapped);
  CloseHandle(Overlapped.hEvent);
  return nNumberOfBytesToRead;
}

//----- (00000001800018B0) ----------------------------------------------------
__int64 __fastcall SerialPortWrite(__int64 a1, unsigned int a2)
{
  unsigned int v2; // ebx
  DWORD v5; // edi
  __int64 v7; // [rsp+20h] [rbp-18h]
  __int64 v8; // [rsp+28h] [rbp-10h]

  v2 = 0;
  if ( a2 )
  {
    while ( 1 )
    {
      v5 = 2048;
      if ( a2 - v2 < 0x800 )
        v5 = a2 - v2;
      LODWORD(v8) = v5;
      LODWORD(v7) = v2;
      sub_180001230(1, "TRACE|%s:%d|escrevendo serial. i=%d , wlen=%d\n", "SerialPortWrite", 197LL, v7, v8);
      if ( (unsigned int)sub_180001390((LPCVOID)(a1 + v2), v5) != 1 )
        return 4294965291LL;
      Sleep(0xFAu);
      v2 += v5;
      if ( v2 >= a2 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    LODWORD(v8) = v2;
    sub_180001230(1, "DVARI|%s:%d|[%s]: %d\n", "SerialPortWrite", 203LL, "i", v8);
    return v2;
  }
}
// 1800018FF: variable 'v7' is possibly undefined
// 1800018FF: variable 'v8' is possibly undefined

//----- (0000000180001980) ----------------------------------------------------
BOOL SerialPortClose()
{
  BOOL result; // eax

  if ( hObject )
  {
    result = CloseHandle(hObject);
    hObject = 0LL;
  }
  return result;
}

//----- (0000000180001F74) ----------------------------------------------------
char sub_180001F74()
{
  if ( !sub_180002804() )
    return 0;
  if ( !sub_180002804() )
  {
    sub_180002804();
    return 0;
  }
  return 1;
}

//----- (0000000180002398) ----------------------------------------------------
void sub_180002398()
{
  InitializeSListHead(&stru_180005600);
}
// 180005600: using guessed type union _SLIST_HEADER stru_180005600;

//----- (00000001800023A8) ----------------------------------------------------
void __fastcall sub_1800023A8()
{
  _std_type_info_destroy_list(&stru_180005600);
}
// 1800027B6: using guessed type __int64 __fastcall _std_type_info_destroy_list(_QWORD);
// 180005600: using guessed type union _SLIST_HEADER stru_180005600;

//----- (00000001800023B4) ----------------------------------------------------
void *sub_1800023B4()
{
  return &unk_180005610;
}

//----- (00000001800023D8) ----------------------------------------------------
void *sub_1800023D8()
{
  return &unk_1800057A0;
}

//----- (0000000180002528) ----------------------------------------------------
__int64 sub_180002528()
{
  _QWORD *i; // rbx
  __int64 result; // rax

  for ( i = qword_1800037A0; i < qword_1800037A0; ++i )
  {
    if ( *i )
      result = ((__int64 (__fastcall *)(_QWORD))*i)(*i);
  }
  return result;
}
// 1800025C0: using guessed type __int64 __fastcall j__guard_check_icall_nop();
// 1800037A0: using guessed type _QWORD qword_1800037A0[2];

//----- (0000000180002574) ----------------------------------------------------
void __fastcall sub_180002574()
{
  _QWORD *i; // rbx

  for ( i = &qword_1800037B0; i < &qword_1800037B0; ++i )
  {
    if ( *i )
      ((void (__fastcall *)(_QWORD))*i)(*i);
  }
}
// 1800025C0: using guessed type __int64 __fastcall j__guard_check_icall_nop();
// 1800037B0: using guessed type _QWORD qword_1800037B0;

//----- (0000000180002804) ----------------------------------------------------
char sub_180002804()
{
  return 1;
}

//----- (0000000180002808) ----------------------------------------------------
__int64 sub_180002808()
{
  return 0LL;
}

// nfuncs=71 queued=21 decompiled=21 lumina nreq=0 worse=0 better=0
// ALL OK, 21 function(s) have been successfully decompiled
